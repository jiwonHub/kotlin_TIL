# 객체 지향 프로그래밍

## 객체 지향 프로그래밍?

컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임이다.

## 객체 지향 프로그래밍의 장점

1. **프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다.**
    - 소프트웨어를 설계할 때 객체 지향적 원리를 잘 적용해 둔 프로그램은 각각의 부품들이 각자의 독립적인 역할을 가지기 때문에 **코드의 변경을 최소화하고 유지보수를 하는 데 유리**하다.
2. **코드의 재사용성을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현할 수 있다.**
3. **인간 친화적이고 직관적인 코드를 작성하기 용이하다.**

객체 지향 프로그래밍의 4가지 특징은 각각 **추상화, 상속, 다형성, 캡슐화**인데, 모두 이러한 객체 지향적 설계의 이점들을 가장 잘 살릴 수 있는 방향으로 발전되어 왔다고 할 수 있다.

## 객체(Object)란?

**객체 지향 프로그래밍의 가장 기본적인 단위이자 시작점**이다. 객체 지향 개념의 가장 기본적인 전제는 실제 세계는 객체들로 구성되어 있으며, 보여지는 모든 현상과 발생하는 모든 사건은 이러한 **객체들 간의 상호작용**을 통해 발생한다는 것에서 출발한다. 따라서 책상, 의자, 시계, 전등, 책 등 우리가 주변에서 흔히 볼 수 있는 “**모든 실재하는 대상**”을 객체 지향 프로그래밍 언어에서는 **객체**라고 부른다. 

한 마디로, 객체는 **우리가 보고 느끼고 인지할 수 있는 그 모든 것**을 의미한다.

## 객체 지향 프로그래밍의 4가지 특징

### 1. 추상화(Abstration)

**객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해 내는 작업**

적용 전

```kotlin
// 사각형 클래스
class Rectangle(val width: Int, val height: Int) {
    fun area(): Int {
        return width * height
    }
}

// 원 클래스
class Circle(val radius: Int) {
    fun area(): Double {
        return 3.14 * radius * radius
    }
}

// 도형들의 면적을 출력하는 함수
fun printArea(shapes: List<Any>) {
    for (shape in shapes) {
        when (shape) {
            is Rectangle -> println("Rectangle area: ${shape.area()}")
            is Circle -> println("Circle area: ${shape.area()}")
        }
    }
}

fun main() {
    val shapes = listOf(Rectangle(3, 4), Circle(5))
    printArea(shapes)
}
```

적용 후

```kotlin
// 추상 클래스 Shape
abstract class Shape {
    abstract fun area(): Double
}

// 사각형 클래스
class Rectangle(val width: Int, val height: Int) : Shape() {
    override fun area(): Double {
        return (width * height).toDouble()
    }
}

// 원 클래스
class Circle(val radius: Int) : Shape() {
    override fun area(): Double {
        return 3.14 * radius * radius
    }
}

// 도형들의 면적을 출력하는 함수
fun printArea(shapes: List<Shape>) {
    for (shape in shapes) {
        println("${shape::class.simpleName} area: ${shape.area()}")
    }
}

fun main() {
    val shapes = listOf(Rectangle(3, 4), Circle(5))
    printArea(shapes)
}
```

### 추상화를 적용했을 때의 이점

1. 유연성과 확장성
    - 추상 클래스 ‘Shape’를 사용하면 새로운 도형 클래스를 추가할 때 기존 코드를 수정할 필요 없이 새로운 클래스만 정의하면 된다.
2. 코드의 재사용성
    - 공통된 인터페이스(추상 클래스)를 통해 다양한 객체를 처리할 수 있으므로, 코드의 재사용성이 높아진다.
3. 유지보수성
    - 코드를 수정할 때 추상화를 통해 서로 독립적인 부분만 수정하면 되므로 유지보수가 용이해진다.
    - 각 도형 클래스는 자신만의 구현을 가지며, 다른 클래스의 변경이 영향을 미치지 않는다.
4. 가독성
    - 추상화된 코드는 더 명확하고 직관적이다. ‘Shape’라는 추상 클래스는 “이 클래스는 도형을 나타낸다”는 명확한 의미를 전달한다.
    - 코드의 구조가 더 체계적으로 보이며, 각 클래스의 역할이 명확해진다.

### 2. 캡슐화(**Encapsulation**)

데이터와 메서드를 하나의 단위로 묶어, 외부에서 접근하지 못하도록 보호하는 개념.

- 데이터 보호: 외부로부터 클래스에 정의된 속성과 기능들을 보호
- 데이터 은닉: 내부의 동작을 감추고 외부에는 필요한 부분만 노출

외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록 하여 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적이 있다.

```kotlin
// 파일명: SuperClass.kt
package package1

open class SuperClass {
    private var a = 1     // private 접근 제어자
    internal var b = 2    // internal 접근 제어자
    protected var c = 3   // protected 접근 제어자
    var d = 4             // public 접근 제어자 (기본값)

    fun printEach() {     // 같은 클래스 내에서는 모두 접근 가능
        println(a)       // 접근 가능
        println(b)       // 접근 가능
        println(c)       // 접근 가능
        println(d)       // 접근 가능
    }
}

fun main() {
    val superClass = SuperClass()

    // println(superClass.a) // 에러: private 접근 제어자
    println(superClass.b)   // internal: 같은 모듈 내에서 접근 가능
    println(superClass.c)   // 에러: protected 접근 제어자
    println(superClass.d)   // public 접근 제어자: 어디서나 접근 가능
}
```

```kotlin
// 파일명: SubClass.kt
package package2

import package1.SuperClass

class SubClass : SuperClass() {
    fun printEach() {
        // println(a) // 에러: private 접근 제어자
        // println(b) // 에러: internal 접근 제어자
        println(c)  // protected: 하위 클래스에서 접근 가능
        println(d)  // public 접근 제어자: 어디서나 접근 가능
    }
}

fun main() {
    val superClass = SuperClass()

    // println(superClass.a) // 에러: private 접근 제어자
    // println(superClass.b) // 에러: internal 접근 제어자
    // println(superClass.c) // 에러: protected 접근 제어자
    println(superClass.d)   // public 접근 제어자: 어디서나 접근 가능
}
```

### 캡슐화를 적용했을 때의 이점

1. 데이터 무결성 유지
    - 숨기고 싶은 데이터를 private으로 설정하여 외부에서 직접 접근하지 못하도록 함으로써, 잘못된 값이 직접 설정되지 않도록 보호할 수 있다,
2. 객체의 상태 보호
    - 객체의 상태는 객체 내부의 메서드를 통해서만 변경될 수 있다. 변경은 getter, 접근은 setter를 통해서 이루어지는 getter/setter의 방법도 존재한다.

### 상속(**Inheritance**)

기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소

앞서 봐왔던 추상화의 연장선에서, 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.

즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 재사용할 수 있어 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 한다.

적용 전

```kotlin
class Car(private var model: String, private var color: String) {
    fun startEngine() {
        println("$model의 엔진을 시동합니다.")
    }

    fun stopEngine() {
        println("$model의 엔진을 끕니다.")
    }

    fun honk() {
        println("경적을 울립니다!")
    }
}

class Truck(private var model: String, private var color: String) {
    fun startEngine() {
        println("$model의 엔진을 시동합니다.")
    }

    fun stopEngine() {
        println("$model의 엔진을 끕니다.")
    }

    fun loadCargo() {
        println("짐을 싣습니다!")
    }
}

fun main() {
    val car = Car("Tesla Model X", "Red")
    car.startEngine()
    car.honk()
    car.stopEngine()

    val truck = Truck("Ford F-150", "Blue")
    truck.startEngine()
    truck.loadCargo()
    truck.stopEngine()
}
```

적용 후

```kotlin
open class Vehicle(private var model: String, private var color: String) {
    fun startEngine() {
        println("$model의 엔진을 시동합니다.")
    }

    fun stopEngine() {
        println("$model의 엔진을 끕니다.")
    }
}

// 자식 클래스 정의
class Car(model: String, color: String) : Vehicle(model, color) {
    fun honk() {
        println("경적을 울립니다!")
    }
}

class Truck(model: String, color: String) : Vehicle(model, color) {
    fun loadCargo() {
        println("짐을 싣습니다!")
    }
}

fun main() {
    val car = Car("Tesla Model X", "Red")
    car.startEngine()
    car.honk()
    car.stopEngine()

    val truck = Truck("Ford F-150", "Blue")
    truck.startEngine()
    truck.loadCargo()
    truck.stopEngine()
}

```

적용 전 코드의 클래스 별로 공통되는 코드를 추상화 한 후 각 클래스는 추상클래스 Vehicle를 상속받아 공통적인 기능을 가지게 된 셈이다. 

### 상속을 적용했을 때 이점

1. 코드 재사용성
    - 동일한 메서드를 여러 클래스에 정의하지 않고, 부모 클래스 Vehicle에 정의함으로써 중복 코드를 제거할 수 있다.
2. 유지보수성 향상
    - 공통된 기능을 부모 클래스에 정의함으로써, 이 기능에 변경이 필요할 경우 부모 클래스만 수정하면 된다.
3. 계층 구조의 명확화
    - Car와 Truck클래스가 Vehicle클래스를 상속받음으로써, 이들 클래스가 Vehicle의 특정 종류임을 명확히 표현할 수 있다.
4. 확장성
    - 새로운 차량 클래스를 추가할 때, Vehicle 클래스를 상속받아 필요한 기능만 추가하면 되므로, 코드 확장이 용이해진다.

### 4. 다형성

객체 지향 프로그래밍의 꽃. **어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질**. 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체 지향의 특성을 의미한다. 대표적인 예로 **메서드 오버라이딩**과 **메서드 오버로딩**이 있다.

적용 전

```kotlin
class Car(private var model: String) {
    fun startEngine() {
        println("$model의 엔진을 시동합니다.")
    }
}

class Truck(private var model: String) {
    fun startEngine() {
        println("$model의 엔진을 시동합니다.")
    }
}

fun main() {
    val car = Car("Tesla Model X")
    val truck = Truck("Ford F-150")

    // 차량의 엔진을 시동하는 함수
    fun startVehicle(vehicle: Any) {
        when (vehicle) {
            is Car -> vehicle.startEngine()
            is Truck -> vehicle.startEngine()
            else -> println("Unknown vehicle")
        }
    }

    startVehicle(car)
    startVehicle(truck)
}
```

적용 후 

```kotlin
interface Vehicle {
    fun startEngine()
}

// 자식 클래스 정의
class Car(private var model: String) : Vehicle {
    override fun startEngine() {
        println("$model (Car)의 엔진을 시동합니다.")
    }
}

class Truck(private var model: String) : Vehicle {
    override fun startEngine() {
        println("$model (Truck)의 엔진을 시동합니다.")
    }
}

fun main() {
    val car: Vehicle = Car("Tesla Model X")
    val truck: Vehicle = Truck("Ford F-150")

    // 다형성을 활용한 함수
    fun startVehicle(vehicle: Vehicle) {
        vehicle.startEngine()
    }

    startVehicle(car)
    startVehicle(truck)
}
```

인터페이스를 통해 각 클래스에서 startEngine를 오버라이딩해서 재정의 하는 모습이다. 이로써 각 클래스 즉, 각 상황 또는 역할에 맞게 startEngine 메서드가 다르게 작동된다.

### 다형성을 적용했을 때 이점

1. 코드의 유연성 증가
    - 인터페이스를 통해 여러 클래스가 동일한 메서드를 구현할 수 있으므로 코드가 더욱 유연해진다.
2. 유지보수성 향상
    - 새로운 차량 종류가 추가될 때, Vehicle 인터페이스를 구현하면 된다. 기존 코드를 수정할 필요가 없다.

위와 같이 같은 이름의 메서드가 상황에 따라 다른 역할을 수행하는 것으로 활용할 수 있지만, 더 중요한 개념이 있다.

> 객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것이다.
> 

```kotlin
class Driver {
    fun drive(car: Car) {
        car.moveForward()
        car.moveBackward()
    }

    fun drive(motorBike: MotorBike) {
        motorBike.moveForward()
        motorBike.moveBackward()
    }
}

fun main() {
    val car = Car()
    val motorBike = MotorBike()
    val driver = Driver()

    driver.drive(car)
    driver.drive(motorBike)
}
```

위 코드에서 확인할 수 있듯이, Driver 클래스의 코드는 매우 간단하다. 즉, 매개변수로 자동차나 오토바이객체를 전달받아 운전하는 것이다. 이렇게 하나의 객체가 다른 객체의 속성과 기능에 접근하여 어떤 기능을 사용할 때, **A클래스는 B클래스에 의존한다**고 표현한다.

같은 맥락으로, 위의 코드 예제를 도식을 사용하여 표현하면 아래와 같이 그려볼 수 있을 것이고, **Driver클래스가 Car클래스와 MotorBike클래스에 의존**하고 있다 라고 설명할 수 있다. 즉 Driver클래스와 다른 두 개의 클래스가 서로 직접적인 관계를 가지고 있는데, 이러한 상황을 **객체들 간의 결합도가 높다**고 표현한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a8dcaf93-7993-4615-abbc-cea9b7d78243/456eaa45-102b-45bd-bbe5-62c17e1be5dc/Untitled.png)

그러나 이렇게 결합도가 높으면 객체 지향적인 설계를 하는 데 매우 불리하다.

이동수단이 자동차나 오토바이가 아닌 다른 모든 이동수단이 추가되면 Driver클래스의 코드는 반복되는 코드를 매우 많이 작성해야 할 것이다.

```kotlin
class Driver {

    fun drive(car: Car) {
        car.moveForward()
        car.moveBackward()
    }

    fun drive(motorBike: MotorBike) {
        motorBike.moveForward()
        motorBike.moveBackward()
    }

    fun drive(bus: Bus) {
        bus.moveForward()
        bus.moveBackward()
    }

    fun drive(train: Train) {
        train.moveForward()
        train.moveBackward()
    }
}
```

또한 어떤 새로운 상황이 발생해서, MotorBike클래스가 다른 클래스 NotorCycle클래스로 변경되어야 하는 경우라면 Driver 안에 매개변수로 전달되는 참조변수의 타입과 참조변수를 수정할 수밖에 없다. 

이런 맥락에서, 객체 지향 프로그래밍은 지금까지 학습한 추상화, 상속, 그리고 다형성의 특성을 활용하여 프로그래밍을 설계할 때 **역할**과 **구현을 구분**하여 **객체들 간의 직접적인 결합을 피하고, 느슨한 관계 설정을 통해 보다 유연하고 변경이 용이한 프로그램 설계**를 가능하게 만들었다.

Vehicle 인터페이스

```kotlin
interface Vehicle {
    fun moveForward()
    fun moveBackward()
}
```

Car 클래스

```kotlin
class Car : Vehicle {
    override fun moveForward() {
        println("🚗가 앞으로 전진합니다🚙")
    }

    override fun moveBackward() {
        println("🚗가 뒤로 후진합니다🚙")
    }
}
```

MotorBike 클래스

```kotlin
class MotorBike : Vehicle {
    override fun moveForward() {
        println("🏍가 앞으로 전진합니다🏍")
    }

    override fun moveBackward() {
        println("🏍가 뒤로 후진합니다🏍")
    }
}
```

Driver 클래스

```kotlin
class Driver {
    fun drive(vehicle: Vehicle) {
        vehicle.moveForward()
        vehicle.moveBackward()
    }
}
```

Main 실행 클래스

```kotlin
fun main() {
    val car = Car()
    val motorBike = MotorBike()
    val driver = Driver()

    driver.drive(car)
    driver.drive(motorBike)
}
```

Driver클래스를 살펴보면 다형성 적용 이전 코드와 비교해봤을 때 매우 간결해졌다는 것을 알 수 있다. 핵심은 drive메서드로 전달되는 매개변수의 타입을 상위 클래스인 인터페이스 타입 Vehicle로 변경한 것이다. 이제 다형성의 세례를 받은 drive메서드의 매개변수로 인터페이스를 구현한 객체라면 무엇이든 전달이 될 수 있게 되었다. 위 코드를 다시 도식으로 나타내보면 다음과 같다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a8dcaf93-7993-4615-abbc-cea9b7d78243/f08d0363-5b15-4293-bd2c-b848f74d7e7c/Untitled.png)

앞서 봤었던 도식에서는 Driver클래스가 Car와 MotorBike클래스 각각과 직접적으로 연결되어 

강한 결합도를 보였지만, 이제는 Vehicle 인터페이스를 통해 간접적으로 연결되어 결합도가 낮아졌다. 따라서, 이제 Driver클래스는 더 이상 **각각의 클래스 내부의 변경이나 다른 객체가 새롭게 교체되는 것을 신경 쓰지 않아도 인터페이스에만 의존하여 수정이 있을 때마다 코드 변경을 하지 않아도 된다.**
